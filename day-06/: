package main

import (
	"fmt"
	"os"
	"strings"
	"time"
)

const debugEnabled = false

type Direction int

const (
	Up    Direction = 0
	Right Direction = 1
	Down  Direction = 2
	Left  Direction = 3
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func getLines(filename string) []string {
	data, err := os.ReadFile(filename)
	check(err)
	return strings.Split(string(data), "\n")
}

func secondPart(lines []string) int {
	position := [2]int{-1, -1}
	direction := Up
	width := -1
	height := len(lines)

	for y, line := range lines {
		if line == "" {
			continue
		}

		if width == -1 {
			width = len(line)
		}

		for x, c := range line {
			if c == '^' {
				position = [2]int{x, y}
				break
			}
		}

		if position[0] != -1 {
			break
		}
	}

	places := make([][2]int, 0, width*height)
	startingPosition := position

	debug("Starting at %v:%v\n", position[0], position[1])
	loopFound := false
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			for {
				updatePosition(lines, &position, &direction, &places, width, height)

				if position[0] == -1 {
					break
				}
			}
		}
	}

	// for {
	// 	updatePosition(lines, &position, &direction, &places, width, height)
	//
	// 	if position[0] == -1 {
	// 		break
	// 	}
	// }

	return len(places)
}

func firstPart(lines []string) int {
	position := [2]int{-1, -1}
	direction := Up
	width := -1
	height := len(lines)

	for y, line := range lines {
		if line == "" {
			continue
		}

		if width == -1 {
			width = len(line)
		}

		for x, c := range line {
			if c == '^' {
				position = [2]int{x, y}
				break
			}
		}

		if position[0] != -1 {
			break
		}
	}

	places := make([][2]int, 0, width*height)

	debug("Starting at %v:%v\n", position[0], position[1])
	for {
		updatePosition(lines, &position, &direction, &places, width, height)

		if position[0] == -1 {
			break
		}
	}

	return len(places)
}

func updatePosition(lines []string, pos *[2]int, d *Direction, places *[][2]int, w int, h int) {
	nextPosition := *pos
	prevPosition := *pos
	xFactor := 0
	yFactor := 0

	// Index starts from top-left
	if *d == Up {
		yFactor = -1
	} else if *d == Down {
		yFactor = 1
	}

	if *d == Right {
		xFactor = 1
	} else if *d == Left {
		xFactor = -1
	}

	for {
		debug("Moving %v\n", *d)
		nextPosition[0] += xFactor
		nextPosition[1] += yFactor
		debug("Direction: %v - New coords: %v\n", []int{xFactor, yFactor}, nextPosition)

		if nextPosition[0] > w-1 || nextPosition[0] < 0 || nextPosition[1] > h-1 || nextPosition[1] < 0 || lines[nextPosition[1]] == "" {
			debug("BREAK\n")
			*pos = [2]int{-1, -1}
			*d = Up
			return
		}

		if lines[nextPosition[1]][nextPosition[0]] == '#' {
			debug("STOP - Obstacle met at %v:%v\n", nextPosition[0], nextPosition[1])
			*pos = prevPosition
			turnRight(d)
			return
		}

		addPlace(places, nextPosition)
		prevPosition = nextPosition
	}
}

func addPlace(places *[][2]int, newCoords [2]int) {
	found := false

	for _, coords := range *places {
		if coords[0] == newCoords[0] && coords[1] == newCoords[1] {
			debug("existing step step %v (%v)\n", newCoords, len(*places))
			found = true
		}
	}

	if !found {
		debug("add new step %v (%v)\n", newCoords, len(*places))
		*places = append(*places, [2]int{newCoords[0], newCoords[1]})
	}
}

func debug(format string, a ...any) {
	if debugEnabled {
		fmt.Printf(format, a...)
	}
}

func turnRight(d *Direction) {
	debug("Turned from %v to %v\n", *d, (*d+1)%4)
	*d = (*d + 1) % 4
}

func main() {
	lines := getLines("./test_input.txt")
	start := time.Now()
	fmt.Printf("First part result: %v (%v)\n", firstPart(lines), time.Since(start))
	start = time.Now()
	fmt.Printf("Second part result: %v (%v)\n", secondPart(lines), time.Since(start))
}
